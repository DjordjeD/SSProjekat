// D:\Helper\Mira\SS\Asembler\Asembler\src\lexer.cpp generated by reflex 2.1.4 from D:\Helper\Mira\SS\Asembler\Asembler\spec\test.l

#define REFLEX_VERSION "2.1.4"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define REFLEX_OPTION_header_file         "D:\\Helper\\Mira\\SS\\Asembler\\Asembler\\h\\lexer.h"
#define REFLEX_OPTION_lex                 lex
#define REFLEX_OPTION_lexer               Lexer
#define REFLEX_OPTION_outfile             "D:\\Helper\\Mira\\SS\\Asembler\\Asembler\\src\\lexer.cpp"
#define REFLEX_OPTION_token_type          Token

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top user code                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 1 "D:\\Helper\\Mira\\SS\\Asembler\\Asembler\\spec\\test.l"


    #include "tokens.h"
    using namespace std;
    using namespace ss::lexer;


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  ABSTRACT LEXER CLASS                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/abslexer.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

class Lexer : public reflex::AbstractLexer<reflex::Matcher> {
 public:
  typedef reflex::AbstractLexer<reflex::Matcher> AbstractBaseLexer;
  Lexer(
      const reflex::Input& input = reflex::Input(),
      std::ostream&        os    = std::cout)
    :
      AbstractBaseLexer(input, os)
  {
  }
  static const int INITIAL = 0;
  static const int STATE_COMMENT = 1;
  virtual Token lex(void);
  Token lex(const reflex::Input& input)
  {
    in(input);
    return lex();
  }
  Token lex(const reflex::Input& input, std::ostream *os)
  {
    in(input);
    if (os)
      out(*os);
    return lex();
  }
};

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %{ user code %}                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 8 "D:\\Helper\\Mira\\SS\\Asembler\\Asembler\\spec\\test.l"
// dodajemo opciju da nam je povratna vrednost token
#line 11 "D:\\Helper\\Mira\\SS\\Asembler\\Asembler\\spec\\test.l"
// definisemo stanje za parsiranje komentara

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

Token Lexer::lex(void)
{
  static const char *REGEX_INITIAL = "(?m)((?:\\r?\\n))|((?:(?:\\Q.global\\E)))|((?:(?:\\Q.extern\\E)))|((?:(?:\\Q.section\\E)))|((?:(?:\\Q.end\\E)))|((?:(?:\\.byte)|(?:\\.word)))|((?:(?:\\Q.equ\\E)))|((?:(?:\\Q:\\E)))|((?:(?:\\Q.skip\\E)))|((?:(?:\\Q,\\E)))|((?:(?:\\Q+\\E)))|((?:(?:\\Q-\\E)))|((?:(?:\\Q*\\E)))|((?:(?:\\Q$\\E)))|((?:(?:\\Q(\\E)))|((?:(?:\\Q)\\E)))|((?:%(?:pc|(?:r[0-7](?:l|h)?))))|((?:(?:[1-9][0-9]*)|(?:0[0-7]*)|(?:0x[0-9A-Fa-f]+)))|((?:[A-Za-z][0-9A-Z_a-z]*))|((?:(?:\\Q;\\E)))|((?:[\\x09\\x20]))|((?:.))";
  static const reflex::Pattern PATTERN_INITIAL(REGEX_INITIAL);
  static const char *REGEX_STATE_COMMENT = "(?m)((?:\\r?\\n))|((?:.))";
  static const reflex::Pattern PATTERN_STATE_COMMENT(REGEX_STATE_COMMENT);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
  }
  while (true)
  {
    switch (start())
    {
      case INITIAL:
        matcher().pattern(PATTERN_INITIAL);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
#line 60 "D:\\Helper\\Mira\\SS\\Asembler\\Asembler\\spec\\test.l"
{ return Token(TokenType::FILE_END, str());    }
            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule D:\Helper\Mira\SS\Asembler\Asembler\spec\test.l:41: {line_end} :
#line 41 "D:\\Helper\\Mira\\SS\\Asembler\\Asembler\\spec\\test.l"
{ return Token(TokenType::LINE_END, str()); }
            break;
          case 2: // rule D:\Helper\Mira\SS\Asembler\Asembler\spec\test.l:42: {global} :
#line 42 "D:\\Helper\\Mira\\SS\\Asembler\\Asembler\\spec\\test.l"
{ return Token(TokenType::GLOBAL, str());      }
            break;
          case 3: // rule D:\Helper\Mira\SS\Asembler\Asembler\spec\test.l:43: {extern} :
#line 43 "D:\\Helper\\Mira\\SS\\Asembler\\Asembler\\spec\\test.l"
{ return Token(TokenType::EXTERN, str());      }
            break;
          case 4: // rule D:\Helper\Mira\SS\Asembler\Asembler\spec\test.l:44: {section} :
#line 44 "D:\\Helper\\Mira\\SS\\Asembler\\Asembler\\spec\\test.l"
{ return Token(TokenType::SECTION, str());     }
            break;
          case 5: // rule D:\Helper\Mira\SS\Asembler\Asembler\spec\test.l:45: {end} :
#line 45 "D:\\Helper\\Mira\\SS\\Asembler\\Asembler\\spec\\test.l"
{ return Token(TokenType::END, str());         }
            break;
          case 6: // rule D:\Helper\Mira\SS\Asembler\Asembler\spec\test.l:46: {data_def} :
#line 46 "D:\\Helper\\Mira\\SS\\Asembler\\Asembler\\spec\\test.l"
{ return Token(TokenType::DATA_DEF, str());    }
            break;
          case 7: // rule D:\Helper\Mira\SS\Asembler\Asembler\spec\test.l:47: {equ} :
#line 47 "D:\\Helper\\Mira\\SS\\Asembler\\Asembler\\spec\\test.l"
{ return Token(TokenType::EQU, str());         }
            break;
          case 8: // rule D:\Helper\Mira\SS\Asembler\Asembler\spec\test.l:48: {colon} :
#line 48 "D:\\Helper\\Mira\\SS\\Asembler\\Asembler\\spec\\test.l"
{ return Token(TokenType::COLON, str());       }
            break;
          case 9: // rule D:\Helper\Mira\SS\Asembler\Asembler\spec\test.l:49: {skip} :
#line 49 "D:\\Helper\\Mira\\SS\\Asembler\\Asembler\\spec\\test.l"
{ return Token(TokenType::SKIP, str());        }
            break;
          case 10: // rule D:\Helper\Mira\SS\Asembler\Asembler\spec\test.l:50: {comma} :
#line 50 "D:\\Helper\\Mira\\SS\\Asembler\\Asembler\\spec\\test.l"
{ return Token(TokenType::COMMA, str());       }
            break;
          case 11: // rule D:\Helper\Mira\SS\Asembler\Asembler\spec\test.l:51: {plus} :
#line 51 "D:\\Helper\\Mira\\SS\\Asembler\\Asembler\\spec\\test.l"
{ return Token(TokenType::PLUS, str());        }
            break;
          case 12: // rule D:\Helper\Mira\SS\Asembler\Asembler\spec\test.l:52: {minus} :
#line 52 "D:\\Helper\\Mira\\SS\\Asembler\\Asembler\\spec\\test.l"
{ return Token(TokenType::MINUS, str());       }
            break;
          case 13: // rule D:\Helper\Mira\SS\Asembler\Asembler\spec\test.l:53: {star} :
#line 53 "D:\\Helper\\Mira\\SS\\Asembler\\Asembler\\spec\\test.l"
{ return Token(TokenType::STAR, str());        }
            break;
          case 14: // rule D:\Helper\Mira\SS\Asembler\Asembler\spec\test.l:54: {dollar} :
#line 54 "D:\\Helper\\Mira\\SS\\Asembler\\Asembler\\spec\\test.l"
{ return Token(TokenType::DOLLAR, str());      }
            break;
          case 15: // rule D:\Helper\Mira\SS\Asembler\Asembler\spec\test.l:55: {lparen} :
#line 55 "D:\\Helper\\Mira\\SS\\Asembler\\Asembler\\spec\\test.l"
{ return Token(TokenType::LPAREN, str());      }
            break;
          case 16: // rule D:\Helper\Mira\SS\Asembler\Asembler\spec\test.l:56: {rparen} :
#line 56 "D:\\Helper\\Mira\\SS\\Asembler\\Asembler\\spec\\test.l"
{ return Token(TokenType::RPAREN, str());      }
            break;
          case 17: // rule D:\Helper\Mira\SS\Asembler\Asembler\spec\test.l:57: {register} :
#line 57 "D:\\Helper\\Mira\\SS\\Asembler\\Asembler\\spec\\test.l"
{ return Token(TokenType::REGISTER, str());    }
            break;
          case 18: // rule D:\Helper\Mira\SS\Asembler\Asembler\spec\test.l:58: {literal} :
#line 58 "D:\\Helper\\Mira\\SS\\Asembler\\Asembler\\spec\\test.l"
{ return Token(TokenType::LITERAL, str());     }
            break;
          case 19: // rule D:\Helper\Mira\SS\Asembler\Asembler\spec\test.l:59: {symbol} :
#line 59 "D:\\Helper\\Mira\\SS\\Asembler\\Asembler\\spec\\test.l"
{ return Token(TokenType::SYMBOL, str());      }
            break;
          case 20: // rule D:\Helper\Mira\SS\Asembler\Asembler\spec\test.l:61: {comment} :
#line 61 "D:\\Helper\\Mira\\SS\\Asembler\\Asembler\\spec\\test.l"
{ start(STATE_COMMENT);                        }
            break;
          case 21: // rule D:\Helper\Mira\SS\Asembler\Asembler\spec\test.l:62: {blanks} :
#line 62 "D:\\Helper\\Mira\\SS\\Asembler\\Asembler\\spec\\test.l"
{ }
            break;
          case 22: // rule D:\Helper\Mira\SS\Asembler\Asembler\spec\test.l:63: {irrelevant} :
#line 63 "D:\\Helper\\Mira\\SS\\Asembler\\Asembler\\spec\\test.l"
{ }


            break;
        }
        break;
      case STATE_COMMENT:
        matcher().pattern(PATTERN_STATE_COMMENT);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
#line 60 "D:\\Helper\\Mira\\SS\\Asembler\\Asembler\\spec\\test.l"
{ return Token(TokenType::FILE_END, str());    }
            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule D:\Helper\Mira\SS\Asembler\Asembler\spec\test.l:66: {line_end} :
#line 66 "D:\\Helper\\Mira\\SS\\Asembler\\Asembler\\spec\\test.l"
{ start(INITIAL); }
            break;
          case 2: // rule D:\Helper\Mira\SS\Asembler\Asembler\spec\test.l:67: {irrelevant} :
#line 67 "D:\\Helper\\Mira\\SS\\Asembler\\Asembler\\spec\\test.l"
{ }

            break;
        }
        break;
      default:
        start(0);
    }
  }
}
